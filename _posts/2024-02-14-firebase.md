---
title: Turn Firebase Into A Local-First Reactive Experience
author: Julien Verlaguet
category: Reactive_programming
layout: post
---

Ever wondered why JSON databases became so popular? It's because they
let you put your objects straight into the database without worrying
about schemas. Plus, if your app runs without a server, everything you
need is right there on the client, synced and ready at your
fingertips.

But there's a catch. The query language often leaves much to be
desired, and you find yourself constantly making trips to the
server. This can make your app feel slow and pretty much useless when
you're offline.

What if you could keep all your data local, always synced, and easily
searchable with SQL? Well, you can, and it's surprisingly simple with
SKDB. We'll use Firebase for our example, but the same approach works
with any JSON database. Let's jump in!

## Getting Started

First up, the setup. We need to connect to Firebase and get everything
ready. We've even set up a demo database specifically for this
walkthrough (the whole code is available [here](https://github.com/SkipLabs/firebase-skdb)).

```javascript
import { initializeApp } from "firebase/app";
import { getDatabase, ref, onValue } from "firebase/database";
import { createSkdb } from "skdb";

const firebaseConfig = {
  databaseURL: "https://skdb-demo-default-rtdb.firebaseio.com",
};

const app = initializeApp(firebaseConfig);
```

## Data Ingestion

Next, we'll create an SKDB instance and feed it our JSON data that
came from Firebase.

```javascript
const skdb = await createSkdb();

await skdb.exec("CREATE TABLE json_products (v JSON);");

const db = getDatabase();
const dbRef = ref(db, '/');

let data = await new Promise((resolve, reject) =>
  onValue(dbRef, (snapshot) => resolve(snapshot.val()))
);

await skdb.insertMany('json_products',
  data.map(x => { return {v: JSON.stringify(x)}; })
);
```

## Making JSON Data SQL-Friendly

So far, we've just dumped a bunch of JSON into an SQL table. But
before we dive deeper, let's see what our data looks like. You can do
this using the `json_infer_schema` function (the function
`json_schema_pretty` makes the result more readable).

```javascript
console.log((await skdb.exec(`
  SELECT json_schema_pretty(json_infer_schema(v)) AS schema
    FROM json_products
`))[0].schema
);
```

The result:

```
  {
    "brand": string,
    "category": string,
    "description": string,
    "discountPercentage": int | float,
    "id": string,
    "images": [string],
    "price": int,
    "rating": int | float,
    "stock": int,
    "thumbnail": string,
    "title": string
  }
```

Now, we get a clear view of our data, showing us details like brand,
category, description, and more. Even though most of the data is
straightforward, there's some structure to it, especially with the
`images` field.

Next, we transform this data into a more SQL-friendly format. We start
with the products, creating a **reactive view** for them using a
special feature called `json_extract`. This allows us to select
specific elements from our JSON to include in our view. A **reactive
view** is always maintained up-to-date by the database, so any change
in the `json_product` table will be reflected in the view `products`.

```javascript
await skdb.exec(`
  CREATE REACTIVE VIEW products AS
    json_extract(
      json_products,
      v,
      '{
         id<string>,
         brand<string>,
         title<string>,
         category<string>,
         price<int>,
         rating<num>
       }'
  );
`);
```

Then, we ensure products can be looked up by their unique ID and
categories can be quickly searched.

```javascript
await skdb.exec("CREATE UNIQUE INDEX pk_products ON products(id);");
await skdb.exec("CREATE INDEX products_category ON products(category);");
```

For images, since they're stored in arrays, we use a special pattern
`[]` from `json_extract` to flatten them out (the docs for
`json_extract` can be found [here](https://www.skdb.io/json_extract/)).

```javascript
await skdb.exec(`
  CREATE REACTIVE VIEW images AS 
    json_extract(
      json_products,
      v,
      '{
         id<string>,
         thumbnail<string>,
         images[]:image<string>
       }'
    )
`);
```

And just like that, we have two SQL views: `products` and `images`. We
can search them like we would any other SQL table, or add indexes to
them. But there's more! SKDB's reactive nature lets you create any
number of reactive views directly in SQL: defining a client-side data
layer has never been easier!

For example, creating a view for top-rated products:

```javascript
await skdb.exec(`
  CREATE REACTIVE VIEW top_products AS
    SELECT * from products ORDER BY rating DESC LIMIT 10;
`);
```

And if SQL isn't your thing? Guess what? You don't even need to dive
deep into SQL these days, thanks to AI. When your queries start
getting complex, chatGPT can write them for you.

Here's how you do it: just use the `skdb.schema('products')`
function. It'll spit out an SQL table structure that matches your
'products' view. Check out the output below:

```SQL
CREATE TABLE products (
  id TEXT NOT NULL,
  brand TEXT NOT NULL,
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  price INTEGER NOT NULL,
  rating FLOAT NOT NULL
);
```

With this structure, writing a prompt for ChatGPT is a breeze. For
example:

```
Given an SQL table created as follows:
CREATE TABLE products (
  id TEXT NOT NULL,
  brand TEXT NOT NULL,
  title TEXT NOT NULL,
  category TEXT NOT NULL,
  price INTEGER NOT NULL,
  rating FLOAT NOT NULL
);
Can you generate an SQL query to find the top 10 highest-rated brands?
```

And the result is exactly what we asked for:

```sql
SELECT brand, AVG(rating) AS average_rating
  FROM products
  GROUP BY brand
  ORDER BY average_rating DESC
  LIMIT 10;
```

### Watching for Changes

When building reactive applications, it's essential to respond to
database changes in real-time. SKDB simplifies this process by
providing a straightforward method to watch for changes in any SQL
query. The `watchChanges` function allows you to define custom
behavior for handling initial data loads, additions, and
removals. This feature is particularly useful for applications that
require real-time data updates, such as dashboards, live feeds, or any
system that relies on the latest information.

Here's an example of how to use `skdb.watchChanges`:

```javascript
await skdb.watchChanges(
  "SELECT * FROM products",
  {},
  (initialRows) => {
    // Handle the initial set of rows
    console.log("Initial data:", initialRows);
  },
  (added, removed) => {
    // Efficiently manage additions
    added.forEach(row => {
      console.log("ADDED:", JSON.stringify(row));
    });

    // Handle removals with care
    removed.forEach(row => {
      console.log("REMOVED:", JSON.stringify(row));
    });
  }
);
```

This approach ensures that your application remains efficient and
responsive, only reacting to changes that directly affect your
dataset.

### Simplifying Reactivity with `useQuery`

For developers working within the React ecosystem, managing state and
reactivity can sometimes become cumbersome, especially when dealing
with external data sources like databases. SKDB addresses this
challenge with the `useQuery` hook, part of `skdb-react`, designed to
seamlessly integrate SQL queries into your React components. This hook
automatically refreshes your component whenever the underlying data
changes, ensuring that your UI is always in sync with your database.

Integrating `useQuery` is straightforward and significantly simplifies
data management:

```javascript
const products = useQuery("SELECT * FROM products LIMIT 10");
// The component automatically updates when one of the first 10 products changes
```

This pattern not only reduces boilerplate code but also encapsulates
the complexity of data fetching and synchronization, allowing you to
focus on building your application's core features.

## Tying it all together

Finally, we need to watch the changes coming from Firebase to have a
real end-to-end reactive experience. You can use the `onSnapshot`
primitive to listen to the changes and have them reflected in
SKDB. But also the other way around, you can watch for the local
changes (using the primitive `watchChanges`) and have them reflected
in Firebase. Since this code is not very hard to write, and somewhat
application specific, we leave that as an exercise to the reader ;)

# Conclusion

In conclusion, leveraging the power of JSON databases like Firebase
alongside a tool like SKDB can dramatically enhance your application's
data handling capabilities. By combining the flexibility of JSON with
the robust querying capabilities of SQL, you can create a highly
responsive, efficient, and dynamic application that stays in sync
across all user interactions.

Embrace the future of database management with SKDB and see how it
transforms your application development process!

![alt text](../img/until_next_time.png){:width="100%"}{:.centered}
